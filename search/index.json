[{"content":"🎉 建博客成功！ 欢迎来到我的技术博客！这是我的第一篇文章，标志着我正式开始了技术写作之旅。\n关于这个博客 这个博客主要用来分享我在编程学习和工作中的心得体会，主要会涉及以下技术领域：\n编程语言: Java, Go, C++, Python 算法与数据结构: 算法题解、数据结构分析 技术总结: 项目经验、技术难点解决方案 学习笔记: 新技术学习记录 未来计划 持续更新技术文章 分享实际项目经验 记录学习过程中的思考 期待与大家一起交流学习！ 🚀\n","date":"2025-07-22T17:09:54+08:00","permalink":"https://skylm808.github.io/p/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%88%90%E5%8A%9F/","title":"建博客成功！"},{"content":"链表反转：头插法与双指针迭代法的区别 链表反转是一个经典的算法问题，本文将介绍两种常见的方法：头插法和双指针迭代法。本文将讨论它们的区别，并附上核心代码示例（使用Go）。\n头插法 头插法通过不断将原链表的节点插入到一个新链表的头部来实现反转。这种方法需要一个辅助链表头部。比如力扣中的 92. 反转链表 II\n核心思想：\n初始化一个新头节点（dummy）。 遍历原链表，将每个节点插入到新头节点的后面。 核心代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type ListNode struct { Val int Next *ListNode } // 头插法：利用 dummy 头构建新链表 func reverseList(head *ListNode) *ListNode { dummy := \u0026amp;ListNode{} // 新链表的虚拟头 for head != nil { next := head.Next // 先保存后继 head.Next = dummy.Next // 插到 dummy 后面 dummy.Next = head head = next } return dummy.Next } 双指针迭代法 双指针迭代法使用两个指针（prev 和 curr）来反转链表的指向。比如力扣中的 25. K 个一组翻转链表\n核心思想：\n初始化 prev 为 nil，curr 为 head。 遍历链表，改变 curr 的 next 指向 prev，然后移动指针。 核心代码 1 2 3 4 5 6 7 8 9 10 11 12 // 双指针迭代法：原地反转 func reverseList(head *ListNode) *ListNode { var prev *ListNode cur := head for cur != nil { next := cur.Next // 保存后继 cur.Next = prev // 翻转指针 prev = cur // prev 前进 cur = next // cur 前进 } return prev } 区别 头插法：类似于构建一个新链表，适合需要复制或额外空间的场景。 双指针迭代法：原地反转，不需要额外空间，效率更高。 两种方法的时间复杂度均为 O(n)，空间复杂度为 O(1)。\n","date":"2023-10-01T00:00:00+08:00","permalink":"https://skylm808.github.io/p/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E5%A4%B4%E6%8F%92%E6%B3%95%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"链表反转：头插法与双指针迭代法的区别"},{"content":"深度解析：go-zero 的 Model 层 Redis 缓存机制 在构建高性能微服务时，数据库往往是性能瓶颈。go-zero 框架在 Model 层内置了一套非常高效且自动化的 Redis 缓存机制。本文将基于源码逻辑，详细揭秘它是如何处理 主键缓存、唯一索引缓存 以及 数据一致性 的。\n1. 核心设计哲学：Index Cache（索引缓存） go-zero 并没有采用“大杂烩”式的缓存策略，而是严格遵循 “所有查询最终都回归到 ID” 的设计原则。\n1.1 两种缓存类型 Primary Cache (主键缓存)\nKey: cache:user:id:1 Value: {\u0026quot;Id\u0026quot;:1, \u0026quot;Username\u0026quot;:\u0026quot;admin\u0026quot;, ...} (整行数据的 JSON) 作用: 真正存储数据的地方。 Index Cache (唯一索引缓存)\nKey: cache:user:username:admin / cache:user:phone:138xxxx Value: 1 (对应的 UserID) 作用: 只是一个路标，指向主键。 2. 查询流程：从“两步走”到“一步到位” 场景 A：基于主键查询 (FindOne(id)) 这是最快路径，一步到位。\n代码调用 FindOne(1)。 框架直接查 Redis cache:user:id:1。 Hit: 拿到 JSON，反序列化返回。 Miss: 查 MySQL -\u0026gt; 拿到整行数据 -\u0026gt; 写入 Redis -\u0026gt; 返回。 场景 B：基于唯一索引查询 (FindOneByUsername(\u0026quot;admin\u0026quot;)) 这是典型的“以空间换时间”+“数据归一化”策略。\n第一步 (找 ID): 查 Redis cache:user:username:admin。 拿到 UserID: 1。 第二步 (找数据): 框架内部自动复用 FindOne(1) 的逻辑。 查 Redis cache:user:id:1 拿到详细数据。 为什么这么设计？ 如果我们在 username 的缓存里也存一份完整的 User 数据，那么当用户修改了“昵称”时，我们需要同时更新 id:1 的缓存、username:admin 的缓存、phone:xxxx 的缓存\u0026hellip; 这极易导致数据不一致。\n现在的方案：只需删除 id:1 的缓存，所有索引查询自然就拿到了最新数据（因为它们最终都要去读 id:1）。\n3. 写入与更新流程：Cache-Aside Pattern go-zero 严格遵循 旁路缓存 (Cache-Aside) 模式。\n3.1 什么时候写入缓存？ 只有在读取失败（Cache Miss）时才写入。即 Lazy Load（懒加载）。\n并不是 update 完数据库马上写 Redis。 而是 update 完只删缓存。下次谁来读，谁负责去把数据从 MySQL“搬运”到 Redis。 3.2 更新/删除时的“自动清理” 当你调用 Update(user) 或 Delete(id) 时，框架底层 (sqlc.CachedConn) 会自动执行以下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 伪代码逻辑 func Delete(id) { // 1. 先查出老数据（为了拿到 username, phone 等索引建） data = FindOne(id) // 2. 准备好所有相关的 Redis Keys keys = [ \u0026#34;cache:user:id:1\u0026#34;, \u0026#34;cache:user:username:admin\u0026#34;, \u0026#34;cache:user:phone:138xxxx\u0026#34; ] // 3. 执行事务与清理 Exec(func() { // A. 先删数据库 DB.Delete(id) }, keys...) // B. 数据库删除成功后，并发删除 Redis Keys } 下面是 github.com\\zeromicro\\go-zero@v1.9.4\\core\\stores\\sqlc\\cachedsql.go中的具体代码，这个ExecCtx就是生成的model层代码里面具体执行数据库操作以及删除缓存的方法\n1 2 3 4 5 6 7 8 9 func (cc CachedConn) ExecCtx(ctx context.Context, exec ExecCtxFn, keys ...string) ( sql.Result, error) { res, err := exec(ctx, cc.db) if err != nil { return nil, err } return res, cc.DelCacheCtx(ctx, keys...) } 如果 Redis 里有缓存 -\u0026gt; DEL 命令被执行，缓存被清空。 如果 Redis 里没缓存 -\u0026gt; DEL 命令依然被执行（返回 0），没有任何副作用。 4. 总结 go-zero 的缓存机制通过 Model 代码生成 帮我们屏蔽了复杂的细节：\n数据归一：所有数据实体只存一份（在 ID 缓存里）。 索引映射：唯一索引只存 ID，通过两次查找解决问题。 一致性保证：修改数据库自动级联删除对应的 所有 缓存 Key（包括 ID Key 和 Index Keys）。 这套机制简单、健壮，是解决高并发读问题的最佳实践之一。\n","date":"0001-01-01T00:00:00Z","permalink":"https://skylm808.github.io/p/","title":""}]