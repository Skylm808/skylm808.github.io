[{"content":"🎉 建博客成功！ 欢迎来到我的技术博客！这是我的第一篇文章，标志着我正式开始了技术写作之旅。\n关于这个博客 这个博客主要用来分享我在编程学习和工作中的心得体会，主要会涉及以下技术领域：\n编程语言: Java, Go, C++, Python 算法与数据结构: 算法题解、数据结构分析 技术总结: 项目经验、技术难点解决方案 学习笔记: 新技术学习记录 未来计划 持续更新技术文章 分享实际项目经验 记录学习过程中的思考 期待与大家一起交流学习！ 🚀\n","date":"2025-07-22T17:09:54+08:00","permalink":"https://skylm808.github.io/p/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%88%90%E5%8A%9F/","title":"建博客成功！"},{"content":"链表反转：头插法与双指针迭代法的区别 链表反转是一个经典的算法问题，本文将介绍两种常见的方法：头插法和双指针迭代法。本文将讨论它们的区别，并附上核心代码示例（使用Go）。\n头插法 头插法通过不断将原链表的节点插入到一个新链表的头部来实现反转。这种方法需要一个辅助链表头部。比如力扣中的 92. 反转链表 II\n核心思想：\n初始化一个新头节点（dummy）。 遍历原链表，将每个节点插入到新头节点的后面。 核心代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type ListNode struct { Val int Next *ListNode } // 头插法：利用 dummy 头构建新链表 func reverseList(head *ListNode) *ListNode { dummy := \u0026amp;ListNode{} // 新链表的虚拟头 for head != nil { next := head.Next // 先保存后继 head.Next = dummy.Next // 插到 dummy 后面 dummy.Next = head head = next } return dummy.Next } 双指针迭代法 双指针迭代法使用两个指针（prev 和 curr）来反转链表的指向。比如力扣中的 25. K 个一组翻转链表\n核心思想：\n初始化 prev 为 nil，curr 为 head。 遍历链表，改变 curr 的 next 指向 prev，然后移动指针。 核心代码 1 2 3 4 5 6 7 8 9 10 11 12 // 双指针迭代法：原地反转 func reverseList(head *ListNode) *ListNode { var prev *ListNode cur := head for cur != nil { next := cur.Next // 保存后继 cur.Next = prev // 翻转指针 prev = cur // prev 前进 cur = next // cur 前进 } return prev } 区别 头插法：类似于构建一个新链表，适合需要复制或额外空间的场景。 双指针迭代法：原地反转，不需要额外空间，效率更高。 两种方法的时间复杂度均为 O(n)，空间复杂度为 O(1)。\n如果您有疑问，欢迎评论！\n","date":"2023-10-01T00:00:00+08:00","permalink":"https://skylm808.github.io/p/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E5%A4%B4%E6%8F%92%E6%B3%95%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"链表反转：头插法与双指针迭代法的区别"}]