<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Skylm</title>
        <link>https://skylm808.github.io/post/</link>
        <description>Recent content in Posts on Skylm</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>Skylm</copyright>
        <lastBuildDate>Fri, 16 Jan 2026 08:00:00 +0800</lastBuildDate><atom:link href="https://skylm808.github.io/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>go-zero 的 Model 层 Redis 缓存机制</title>
        <link>https://skylm808.github.io/p/go-zero-%E7%9A%84-model-%E5%B1%82-redis-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Fri, 16 Jan 2026 08:00:00 +0800</pubDate>
        
        <guid>https://skylm808.github.io/p/go-zero-%E7%9A%84-model-%E5%B1%82-redis-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
        <description>&lt;p&gt;在构建高性能微服务时，数据库往往是性能瓶颈。go-zero 在 Model 层内置了一套高效且自动化的 Redis 缓存机制。本文基于源码逻辑，讲清楚它如何处理主键缓存、唯一索引缓存以及数据一致性。&lt;/p&gt;
&lt;h2 id=&#34;1-核心设计哲学index-cache索引缓存&#34;&gt;1. 核心设计哲学：Index Cache（索引缓存）
&lt;/h2&gt;&lt;p&gt;go-zero 并没有采用“大杂烩”式的缓存策略，而是严格遵循 &lt;strong&gt;“所有查询最终都回归到 ID”&lt;/strong&gt; 的设计原则。&lt;/p&gt;
&lt;h3 id=&#34;11-两种缓存类型&#34;&gt;1.1 两种缓存类型
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Primary Cache (主键缓存)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Key&lt;/strong&gt;: &lt;code&gt;cache:user:id:1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value&lt;/strong&gt;: &lt;code&gt;{&amp;quot;Id&amp;quot;:1, &amp;quot;Username&amp;quot;:&amp;quot;admin&amp;quot;, ...}&lt;/code&gt;（整行数据 JSON）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;: 真正存储数据的地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Index Cache (唯一索引缓存)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Key&lt;/strong&gt;: &lt;code&gt;cache:user:username:admin&lt;/code&gt; / &lt;code&gt;cache:user:phone:138xxxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value&lt;/strong&gt;: &lt;code&gt;1&lt;/code&gt;（对应的 UserID）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;: 只是一个路标，指向主键。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-查询流程从两步走到一步到位&#34;&gt;2. 查询流程：从“两步走”到“一步到位”
&lt;/h2&gt;&lt;h3 id=&#34;场景-a基于主键查询findoneid&#34;&gt;场景 A：基于主键查询（&lt;code&gt;FindOne(id)&lt;/code&gt;）
&lt;/h3&gt;&lt;p&gt;这是最快路径，一步到位。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码调用 &lt;code&gt;FindOne(1)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;框架直接查 Redis &lt;code&gt;cache:user:id:1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hit&lt;/strong&gt;: 拿到 JSON，反序列化返回。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Miss&lt;/strong&gt;: 查 MySQL -&amp;gt; 拿到整行数据 -&amp;gt; &lt;strong&gt;写入 Redis&lt;/strong&gt; -&amp;gt; 返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;场景-b基于唯一索引查询findonebyusernameadmin&#34;&gt;场景 B：基于唯一索引查询（&lt;code&gt;FindOneByUsername(&amp;quot;admin&amp;quot;)&lt;/code&gt;）
&lt;/h3&gt;&lt;p&gt;这是典型的“以空间换时间 + 数据归一化”策略。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;第一步（找 ID）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;查 Redis &lt;code&gt;cache:user:username:admin&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;拿到 UserID: &lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;第二步（找数据）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;框架内部自动复用 &lt;code&gt;FindOne(1)&lt;/code&gt; 的逻辑。&lt;/li&gt;
&lt;li&gt;查 Redis &lt;code&gt;cache:user:id:1&lt;/code&gt; 拿到详细数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么这么设计？&lt;/strong&gt;&lt;br&gt;
如果在 &lt;code&gt;username&lt;/code&gt; 的缓存里也存一份完整的 User 数据，当用户修改昵称时，需要同时更新 &lt;code&gt;id:1&lt;/code&gt;、&lt;code&gt;username:admin&lt;/code&gt;、&lt;code&gt;phone:xxxx&lt;/code&gt; 等多份缓存，极易产生不一致。&lt;br&gt;
现在的方案是只维护主键缓存：删除 &lt;code&gt;id:1&lt;/code&gt; 后，所有索引查询都会回到主键缓存，天然一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-写入与更新流程cache-aside-pattern&#34;&gt;3. 写入与更新流程：Cache-Aside Pattern
&lt;/h2&gt;&lt;p&gt;go-zero 严格遵循 &lt;strong&gt;旁路缓存 (Cache-Aside)&lt;/strong&gt; 模式。&lt;/p&gt;
&lt;h3 id=&#34;31-什么时候写入缓存&#34;&gt;3.1 什么时候写入缓存？
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;只有在读取失败（Cache Miss）时才写入&lt;/strong&gt;。即 &lt;code&gt;Lazy Load&lt;/code&gt;（懒加载）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并不是 update 完数据库马上写 Redis。&lt;/li&gt;
&lt;li&gt;而是 update 完只删缓存。下次谁来读，谁负责去把数据从 MySQL“搬运”到 Redis。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-更新删除时的自动清理&#34;&gt;3.2 更新/删除时的“自动清理”
&lt;/h3&gt;&lt;p&gt;当你调用 &lt;code&gt;Update(user)&lt;/code&gt; 或 &lt;code&gt;Delete(id)&lt;/code&gt; 时，框架底层（&lt;code&gt;sqlc.CachedConn&lt;/code&gt;）会自动执行以下操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;18
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 伪代码逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Delete&lt;/span&gt;(id &lt;span style=&#34;color:#8be9fd&#34;&gt;int64&lt;/span&gt;) &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// 1. 先查出老数据（为了拿到 username、phone 等索引键）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    data, _ &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;FindOne&lt;/span&gt;(id)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// 2. 准备所有相关的 Redis Keys&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    keys &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;cache:user:id:1&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;cache:user:username:admin&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;cache:user:phone:138xxxx&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// 3. 执行数据库操作 + 删除缓存&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _, err &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;Exec&lt;/span&gt;(&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt;() &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; DB.&lt;span style=&#34;color:#50fa7b&#34;&gt;Delete&lt;/span&gt;(id)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }, keys&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;下面是 &lt;code&gt;github.com/zeromicro/go-zero@v1.9.4/core/stores/sqlc/cachedsql.go&lt;/code&gt; 中的具体代码，&lt;code&gt;ExecCtx&lt;/code&gt; 是生成的 model 层代码里执行数据库操作并删除缓存的方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; (cc CachedConn) &lt;span style=&#34;color:#50fa7b&#34;&gt;ExecCtx&lt;/span&gt;(ctx context.Context, exec ExecCtxFn, keys &lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;) (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sql.Result, &lt;span style=&#34;color:#8be9fd&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    res, err &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;exec&lt;/span&gt;(ctx, cc.db)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;, err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; res, cc.&lt;span style=&#34;color:#50fa7b&#34;&gt;DelCacheCtx&lt;/span&gt;(ctx, keys&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果 Redis 里有缓存&lt;/strong&gt; -&amp;gt; &lt;code&gt;DEL&lt;/code&gt; 命令被执行，缓存被清空。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果 Redis 里没缓存&lt;/strong&gt; -&amp;gt; &lt;code&gt;DEL&lt;/code&gt; 命令依然被执行（返回 0），没有任何副作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-总结&#34;&gt;4. 总结
&lt;/h2&gt;&lt;p&gt;go-zero 的缓存机制通过 &lt;strong&gt;Model 代码生成&lt;/strong&gt; 帮我们屏蔽了复杂的细节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据归一&lt;/strong&gt;：所有数据实体只存一份（在 ID 缓存里）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;索引映射&lt;/strong&gt;：唯一索引只存 ID，通过两次查找解决问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性保证&lt;/strong&gt;：修改数据库自动级联删除对应的所有缓存 Key（包括 ID Key 和 Index Keys）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这套机制简单、健壮，是解决高并发读问题的最佳实践之一。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Golang slice 与 map 底层详解</title>
        <link>https://skylm808.github.io/p/golang-slice-%E4%B8%8E-map-%E5%BA%95%E5%B1%82%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Thu, 15 Jan 2026 16:39:08 +0800</pubDate>
        
        <guid>https://skylm808.github.io/p/golang-slice-%E4%B8%8E-map-%E5%BA%95%E5%B1%82%E8%AF%A6%E8%A7%A3/</guid>
        <description>&lt;h2 id=&#34;为什么要理解-slice-和-map-的底层&#34;&gt;为什么要理解 slice 和 map 的底层
&lt;/h2&gt;&lt;p&gt;在 Go 里，slice 和 map 是最常用的两类容器。它们看起来简单，但很多性能差异、内存占用、并发问题都和底层实现相关。本文从运行时视角解释 slice 与 map 的内存布局、扩容策略、常见陷阱与最佳实践。&lt;/p&gt;
&lt;p&gt;本文基于 Go 1.18+ 的实现思路，具体细节可能随版本微调，核心概念保持稳定。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;slice-的底层结构&#34;&gt;slice 的底层结构
&lt;/h2&gt;&lt;h3 id=&#34;1-slice-只是一个描述符&#34;&gt;1) slice 只是一个“描述符”
&lt;/h3&gt;&lt;p&gt;slice 本质上是一个结构体，指向一段连续数组，并记录长度与容量（伪代码）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; slice &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    array unsafe.Pointer
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    len   &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cap   &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt; 指向底层数组首元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt; 表示当前可用元素数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cap&lt;/code&gt; 表示底层数组从 &lt;code&gt;array&lt;/code&gt; 起始还能容纳的最大元素数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，slice 的复制是“浅拷贝”。多个 slice 可能共享同一底层数组。&lt;/p&gt;
&lt;h3 id=&#34;2-nil-slice-与-empty-slice&#34;&gt;2) nil slice 与 empty slice
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; s1 []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;          &lt;span style=&#34;color:#6272a4&#34;&gt;// nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s2 &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{}         &lt;span style=&#34;color:#6272a4&#34;&gt;// empty&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s3 &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;)  &lt;span style=&#34;color:#6272a4&#34;&gt;// empty&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s1 == nil&lt;/code&gt; 为 true，&lt;code&gt;len&lt;/code&gt; 与 &lt;code&gt;cap&lt;/code&gt; 都为 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s2&lt;/code&gt;/&lt;code&gt;s3&lt;/code&gt; 的 &lt;code&gt;len&lt;/code&gt;/&lt;code&gt;cap&lt;/code&gt; 为 0，但 &lt;code&gt;s2 == nil&lt;/code&gt; 为 false。&lt;/li&gt;
&lt;li&gt;访问/遍历行为一致，但对 JSON 编码或反射结果可能不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-切片表达式与共享内存&#34;&gt;3) 切片表达式与共享内存
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;5&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; a[&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;]    &lt;span style=&#34;color:#6272a4&#34;&gt;// [2,3]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; a[&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;3&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;4&lt;/span&gt;]  &lt;span style=&#34;color:#6272a4&#34;&gt;// len=2, cap=3 (cap = max - low)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;关键点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 与 &lt;code&gt;a&lt;/code&gt; 共享底层数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a[low:high:max]&lt;/code&gt; 可以显式限制新 slice 的 &lt;code&gt;cap&lt;/code&gt;，避免后续 &lt;code&gt;append&lt;/code&gt; 影响到原数组。&lt;/li&gt;
&lt;li&gt;重新切片不会拷贝数据，只会创建新的 slice 头部。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-append-的扩容策略&#34;&gt;4) append 的扩容策略
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;append&lt;/code&gt; 的行为取决于 &lt;code&gt;cap&lt;/code&gt; 是否够用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;len+appendLen &amp;lt;= cap&lt;/code&gt;，直接在原数组上追加。&lt;/li&gt;
&lt;li&gt;否则分配新数组并拷贝旧数据，再追加新元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扩容策略大致为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小容量时按 2 倍增长。&lt;/li&gt;
&lt;li&gt;大容量时按 ~1.25 倍增长（具体阈值与算法可能随版本变化）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着频繁小步 &lt;code&gt;append&lt;/code&gt; 会产生多次扩容和拷贝。可用 &lt;code&gt;make([]T, 0, n)&lt;/code&gt; 进行预分配。&lt;/p&gt;
&lt;h3 id=&#34;5-内存滞留与切片泄漏&#34;&gt;5) 内存滞留与“切片泄漏”
&lt;/h3&gt;&lt;p&gt;当你从一个很大的 slice 上切一小段时，底层数组依然被引用，导致大块内存无法回收：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;big &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]&lt;span style=&#34;color:#8be9fd&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;20&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;small &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; big[:&lt;span style=&#34;color:#bd93f9&#34;&gt;10&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时即使 &lt;code&gt;small&lt;/code&gt; 的 &lt;code&gt;len&lt;/code&gt; 很小，底层数组仍被 &lt;code&gt;cap&lt;/code&gt; 引用。解决方式是显式拷贝一份：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;small = &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;append&lt;/span&gt;([]&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;byte&lt;/span&gt;(&lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;), small&lt;span style=&#34;color:#ff79c6&#34;&gt;...&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样 &lt;code&gt;small&lt;/code&gt; 只保留需要的那段数据。若只是为了避免后续 &lt;code&gt;append&lt;/code&gt; 污染原数组，可用 &lt;code&gt;full slice&lt;/code&gt; 限制容量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;small &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; big[:&lt;span style=&#34;color:#bd93f9&#34;&gt;10&lt;/span&gt;:&lt;span style=&#34;color:#bd93f9&#34;&gt;10&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注意：限制 &lt;code&gt;cap&lt;/code&gt; 并不能释放大数组本身，真正释放仍需拷贝或让原 slice 失去引用。&lt;/p&gt;
&lt;h3 id=&#34;6-切片内指针未释放&#34;&gt;6) 切片内指针未释放
&lt;/h3&gt;&lt;p&gt;当 slice 元素是指针，或元素包含指针字段时，即使你“缩短”了 slice，底层数组中尾部的旧指针仍会被 GC 扫描，导致对象无法回收：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; Node &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Next &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Node
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;make&lt;/span&gt;([]&lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;Node, &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#bd93f9&#34;&gt;1024&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// ... append 了一堆元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s = s[:&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#6272a4&#34;&gt;// 尾部仍保留旧指针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;正确做法是显式清理引用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;range&lt;/span&gt; s {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s[i] = &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s = s[:&lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;删除元素时也要清掉尾部引用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;copy&lt;/span&gt;(s[i:], s[i&lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;:])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s[&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(s)&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;] = &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;s = s[:&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;len&lt;/span&gt;(s)&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果元素是包含指针的结构体，可用零值清理：&lt;code&gt;var zero T; s[i] = zero&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;7-copy-与-append-的语义&#34;&gt;7) copy 与 append 的语义
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;copy(dst, src)&lt;/code&gt; 会按元素顺序拷贝，允许内存重叠。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;append(dst, src...)&lt;/code&gt; 会把 &lt;code&gt;src&lt;/code&gt; 展开成元素，再追加到 &lt;code&gt;dst&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 &lt;code&gt;dst&lt;/code&gt; 和 &lt;code&gt;src&lt;/code&gt; 共享底层数组时，&lt;code&gt;append&lt;/code&gt; 可能触发扩容，从而得到新的数组；所以行为依赖容量。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;map-的底层结构&#34;&gt;map 的底层结构
&lt;/h2&gt;&lt;h3 id=&#34;1-map-是哈希表&#34;&gt;1) map 是哈希表
&lt;/h3&gt;&lt;p&gt;Go 的 map 底层是哈希表结构，核心是 &lt;code&gt;hmap&lt;/code&gt;（伪结构）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; hmap &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    count     &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;           &lt;span style=&#34;color:#ff79c6&#34;&gt;//当前map中已经存储键值对的总数量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    B         &lt;span style=&#34;color:#8be9fd&#34;&gt;uint8&lt;/span&gt;        &lt;span style=&#34;color:#6272a4&#34;&gt;// 桶数 = 2^B&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    buckets   unsafe.Pointer  &lt;span style=&#34;color:#ff79c6&#34;&gt;//主桶数组指针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    oldbuckets unsafe.Pointer    &lt;span style=&#34;color:#ff79c6&#34;&gt;//旧桶数组指针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nevacuate &lt;span style=&#34;color:#8be9fd&#34;&gt;uintptr&lt;/span&gt;            &lt;span style=&#34;color:#ff79c6&#34;&gt;//下一个要搬迁的桶&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    hash0     &lt;span style=&#34;color:#8be9fd&#34;&gt;uint32&lt;/span&gt;            &lt;span style=&#34;color:#ff79c6&#34;&gt;//哈希种子&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buckets&lt;/code&gt; 指向桶数组（bucket）。&lt;/li&gt;
&lt;li&gt;每个 bucket 固定容纳 8 个 key/value。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oldbuckets&lt;/code&gt; 用于扩容过程中的渐进式搬迁。
&lt;ul&gt;
&lt;li&gt;如果它是 nil：说明 map 当前处于正常状态，没有在扩容。&lt;/li&gt;
&lt;li&gt;如果它非 nil：说明 map 正处于“渐进式扩容”的过程中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hash0&lt;/code&gt; 是随机种子，用于防止 hash 碰撞攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-makemap--建厂与基础设施搭建&#34;&gt;2) make(map) —— 建厂与基础设施搭建
&lt;/h3&gt;&lt;p&gt;以 &lt;code&gt;m := make(map[string]int, 10)&lt;/code&gt; 为例，运行时会做一系列初始化：&lt;/p&gt;
&lt;p&gt;第一阶段：算桶数量（B）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负载因子约为 6.5，每个桶固定 8 个槽位，但不允许满载运行。&lt;/li&gt;
&lt;li&gt;根据 &lt;code&gt;hint&lt;/code&gt; 估算桶数，选择最小的 &lt;code&gt;B&lt;/code&gt; 使得 &lt;code&gt;2^B &amp;gt;= hint / 6.5&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;hint=10&lt;/code&gt;，通常需要 &lt;code&gt;B=1&lt;/code&gt;（2 个桶，16 个槽位），实际会略向上取整以留余量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二阶段：初始化 &lt;code&gt;hmap&lt;/code&gt; 头部&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在堆上分配 &lt;code&gt;hmap&lt;/code&gt;，&lt;code&gt;count=0&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt; 写入、其余字段清零。&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;hash0&lt;/code&gt; 随机种子，防止哈希碰撞攻击（每次进程启动都不同）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第三阶段：分配桶数组&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若 &lt;code&gt;hint &amp;gt; 0&lt;/code&gt;，通常会直接分配桶数组（连续内存）。&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;hint&lt;/code&gt; 很小或为 0，桶数组可能延迟到第一次写入才分配。&lt;/li&gt;
&lt;li&gt;当 key/elem 都不含指针时，会初始化 &lt;code&gt;mapextra&lt;/code&gt; 用于跟踪 overflow bucket，避免被 GC 误回收。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;hint&lt;/code&gt; 只是容量建议，不是硬上限，超过后会触发扩容。&lt;/p&gt;
&lt;h3 id=&#34;3-bucket-的布局&#34;&gt;3) bucket 的布局
&lt;/h3&gt;&lt;p&gt;每个 bucket 里包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tophash[8]&lt;/code&gt;：hash 高位的 8 个标记，用于快速过滤。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keys[8]&lt;/code&gt; 与 &lt;code&gt;values[8]&lt;/code&gt;：真正的 key/value。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;overflow&lt;/code&gt; 指针：当 bucket 满了，链接额外 bucket。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一种“分离桶 + 溢出链”的设计，兼顾了局部性与扩展性。&lt;/p&gt;
&lt;h3 id=&#34;4-写入读取时的哈希流程以-mhello--10086-为例&#34;&gt;4) 写入/读取时的哈希流程（以 m[&amp;ldquo;hello&amp;rdquo;] = 10086 为例）
&lt;/h3&gt;&lt;p&gt;第二阶段：精密的存储过程&lt;/p&gt;
&lt;p&gt;Step 1: 计算哈希值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用哈希函数（例如 aeshash/memhash），结合 &lt;code&gt;h.hash0&lt;/code&gt; 种子与 key 内容。&lt;/li&gt;
&lt;li&gt;得到一个 64 位 hash。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Step 2: 低 B 位定位桶（bucketIndex）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算 &lt;code&gt;bucketIndex = hash &amp;amp; ((1&amp;lt;&amp;lt;B) - 1)&lt;/code&gt;，用低 B 位决定去哪个桶。&lt;/li&gt;
&lt;li&gt;若正在扩容，先触发 &lt;code&gt;growWork&lt;/code&gt; 搬迁对应旧桶，再定位新桶。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Step 3: 计算 tophash（高 8 位指纹）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取 &lt;code&gt;tophash = hash &amp;gt;&amp;gt; (wordbits - 8)&lt;/code&gt; 作为指纹。&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;tophash &amp;lt; minTopHash(5)&lt;/code&gt;，则加上偏移，使其落在 5..255 范围。&lt;/li&gt;
&lt;li&gt;0..4 预留用于空槽与搬迁状态标记。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Step 4: 扫描桶与溢出桶&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历当前桶的 8 个槽位，必要时遍历 overflow bucket。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tophash&lt;/code&gt; 不匹配直接跳过。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tophash&lt;/code&gt; 匹配后再比较真实 key（可能哈希冲突）。&lt;/li&gt;
&lt;li&gt;记录遇到的第一个空槽位（插入候选）。&lt;/li&gt;
&lt;li&gt;若命中同 key，直接覆盖 value 并返回。&lt;/li&gt;
&lt;li&gt;若遇到 &lt;code&gt;emptyRest&lt;/code&gt;，说明后面全空，可提前结束扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Step 5: 插入或扩容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若未找到 key：检查 &lt;code&gt;count+1&lt;/code&gt; 是否超过负载因子，或 overflow 过多。&lt;/li&gt;
&lt;li&gt;若触发扩容，先 grow 再重新走一遍流程。&lt;/li&gt;
&lt;li&gt;否则使用空槽位写入：&lt;code&gt;tophash&lt;/code&gt;、key、value。&lt;/li&gt;
&lt;li&gt;若当前桶已满且没有空槽，申请 overflow bucket 并插入。&lt;/li&gt;
&lt;li&gt;写入后 &lt;code&gt;count++&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读流程与写流程类似，但不会创建新桶或新槽，找不到 key 就返回零值。&lt;/p&gt;
&lt;p&gt;平均复杂度为 O(1)，碰撞或溢出链过长时会退化。&lt;/p&gt;
&lt;p&gt;`&lt;/p&gt;
&lt;h3 id=&#34;5-扩容与渐进式迁移&#34;&gt;5) 扩容与渐进式迁移
&lt;/h3&gt;&lt;p&gt;map 的扩容不是一次性完成，而是插入/访问时逐步“搬迁” bucket：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oldbuckets&lt;/code&gt; 保存旧表，&lt;code&gt;nevacuate&lt;/code&gt; 记录搬迁进度。&lt;/li&gt;
&lt;li&gt;每次 map 操作会顺带搬迁少量桶，摊薄暂停时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6-扩容的两种形式&#34;&gt;6) 扩容的两种形式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;翻倍扩容（B+1）&lt;/strong&gt;&lt;br&gt;
当负载因子过高（约 6.5 个元素/桶）触发，桶数量翻倍，减少冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;等量扩容（same-size grow）&lt;/strong&gt;&lt;br&gt;
当 overflow bucket 过多时触发，桶数量不变，但重新分布元素，缩短溢出链。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-删除与内存收缩&#34;&gt;7) 删除与内存收缩
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;delete(m, key)&lt;/code&gt; 会清掉 key/value，但 map 通常不会自动缩容。大量删除后，map 可能仍占用较大内存。&lt;/p&gt;
&lt;p&gt;释放内存的常见办法是重新创建一个新 map 并拷贝需要的元素。&lt;/p&gt;
&lt;h3 id=&#34;8-nil-map-与并发安全&#34;&gt;8) nil map 与并发安全
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; m &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#8be9fd&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#6272a4&#34;&gt;// nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;读取 &lt;code&gt;m[key]&lt;/code&gt; 返回零值。&lt;/li&gt;
&lt;li&gt;写入会 panic：&lt;code&gt;assignment to entry in nil map&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;map 不是并发安全结构，多个 goroutine 并发写会触发运行时崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并发场景可用 &lt;code&gt;sync.Mutex&lt;/code&gt; 保护或使用 &lt;code&gt;sync.Map&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;9-go-版本差异提示&#34;&gt;9) Go 版本差异提示
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本文以 Go 1.18+ 的 &lt;code&gt;hmap/bucket&lt;/code&gt; 结构为参考，不同版本可能在字段布局和常量上有微调。&lt;/li&gt;
&lt;li&gt;哈希函数实现会随版本与 CPU 特性调整（例如 aeshash/memhash），但整体流程一致。&lt;/li&gt;
&lt;li&gt;扩容阈值与 same-size grow 的触发条件可能会在版本间小幅调参，细节以 &lt;code&gt;GOROOT/src/runtime/map.go&lt;/code&gt; 为准。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;slice-vs-map-的关键对比&#34;&gt;slice vs map 的关键对比
&lt;/h2&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;维度&lt;/th&gt;
          &lt;th&gt;slice&lt;/th&gt;
          &lt;th&gt;map&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;底层结构&lt;/td&gt;
          &lt;td&gt;连续数组 + 头部描述符&lt;/td&gt;
          &lt;td&gt;哈希表&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;访问复杂度&lt;/td&gt;
          &lt;td&gt;O(1) 通过索引&lt;/td&gt;
          &lt;td&gt;O(1) 平均，通过 key&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;内存局部性&lt;/td&gt;
          &lt;td&gt;很好&lt;/td&gt;
          &lt;td&gt;一般&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;适用场景&lt;/td&gt;
          &lt;td&gt;顺序数据、可索引&lt;/td&gt;
          &lt;td&gt;无序查找、去重&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;扩容代价&lt;/td&gt;
          &lt;td&gt;拷贝数组&lt;/td&gt;
          &lt;td&gt;渐进式 rehash&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;常见陷阱与最佳实践&#34;&gt;常见陷阱与最佳实践
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;预分配容量&lt;/strong&gt;&lt;br&gt;
预估长度时使用 &lt;code&gt;make([]T, 0, n)&lt;/code&gt; 或 &lt;code&gt;make(map[K]V, n)&lt;/code&gt;，减少扩容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免共享底层数组引发的副作用&lt;/strong&gt;&lt;br&gt;
不确定是否共享时，可 &lt;code&gt;copy&lt;/code&gt;/&lt;code&gt;append&lt;/code&gt; 生成新 slice。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;map 迭代顺序不稳定&lt;/strong&gt;&lt;br&gt;
Go 刻意随机化遍历顺序，不能依赖顺序逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;谨慎处理大对象切片与指针残留&lt;/strong&gt;&lt;br&gt;
切小 slice 时注意底层数组引用导致的内存滞留；删除/缩短时对指针元素清零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;并发写 map 必须加锁&lt;/strong&gt;&lt;br&gt;
读写混用也需要同步，避免运行时崩溃。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语
&lt;/h2&gt;&lt;p&gt;理解 slice 与 map 的底层实现，可以帮助你在性能调优、内存控制和并发安全方面做出更可靠的选择。写 Go 时不必处处微优化，但知道“它为什么慢”或“为什么占内存”，就能更快定位问题。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>链表反转：头插法与双指针迭代法的区别</title>
        <link>https://skylm808.github.io/p/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E5%A4%B4%E6%8F%92%E6%B3%95%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
        <pubDate>Mon, 08 Dec 2025 10:35:20 +0800</pubDate>
        
        <guid>https://skylm808.github.io/p/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E5%A4%B4%E6%8F%92%E6%B3%95%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88%E8%BF%AD%E4%BB%A3%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
        <description>&lt;h1 id=&#34;链表反转头插法与双指针迭代法的区别&#34;&gt;链表反转：头插法与双指针迭代法的区别
&lt;/h1&gt;&lt;p&gt;链表反转是一个经典的算法问题，本文将介绍两种常见的方法：头插法和双指针迭代法。本文将讨论它们的区别，并附上核心代码示例（使用Go）。&lt;/p&gt;
&lt;h2 id=&#34;头插法&#34;&gt;头插法
&lt;/h2&gt;&lt;p&gt;头插法通过不断将原链表的节点插入到一个新链表的头部来实现反转。这种方法需要一个辅助链表头部。比如力扣中的 92. &lt;a class=&#34;link&#34; href=&#34;https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;反转链表 II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;核心思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化一个新头节点（dummy）。&lt;/li&gt;
&lt;li&gt;遍历原链表，将每个节点插入到新头节点的后面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;核心代码&#34;&gt;核心代码
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;type&lt;/span&gt; ListNode &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Val  &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Next &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ListNode
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 头插法：利用 dummy 头构建新链表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;reverseList&lt;/span&gt;(head &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ListNode) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ListNode {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dummy &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&lt;/span&gt;ListNode{}   &lt;span style=&#34;color:#6272a4&#34;&gt;// 新链表的虚拟头&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; head &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        next &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; head.Next         &lt;span style=&#34;color:#6272a4&#34;&gt;// 先保存后继&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        head.Next = dummy.Next    &lt;span style=&#34;color:#6272a4&#34;&gt;// 插到 dummy 后面&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        dummy.Next = head
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        head = next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; dummy.Next
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;双指针迭代法&#34;&gt;双指针迭代法
&lt;/h2&gt;&lt;p&gt;双指针迭代法使用两个指针（prev 和 curr）来反转链表的指向。比如力扣中的 25. &lt;a class=&#34;link&#34; href=&#34;https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&amp;amp;envId=top-interview-150&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;K 个一组翻转链表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;核心思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 prev 为 nil，curr 为 head。&lt;/li&gt;
&lt;li&gt;遍历链表，改变 curr 的 next 指向 prev，然后移动指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;核心代码-1&#34;&gt;核心代码
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 双指针迭代法：原地反转&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;reverseList&lt;/span&gt;(head &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ListNode) &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ListNode {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; prev &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt;ListNode
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cur &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; head
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; cur &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        next &lt;span style=&#34;color:#ff79c6&#34;&gt;:=&lt;/span&gt; cur.Next   &lt;span style=&#34;color:#6272a4&#34;&gt;// 保存后继&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cur.Next = prev    &lt;span style=&#34;color:#6272a4&#34;&gt;// 翻转指针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        prev = cur         &lt;span style=&#34;color:#6272a4&#34;&gt;// prev 前进&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cur = next         &lt;span style=&#34;color:#6272a4&#34;&gt;// cur 前进&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;return&lt;/span&gt; prev
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;区别&#34;&gt;区别
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;头插法&lt;/strong&gt;：类似于构建一个新链表，适合需要复制或额外空间的场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双指针迭代法&lt;/strong&gt;：原地反转，不需要额外空间，效率更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种方法的时间复杂度均为 O(n)，空间复杂度为 O(1)。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>建博客成功！</title>
        <link>https://skylm808.github.io/p/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%88%90%E5%8A%9F/</link>
        <pubDate>Tue, 22 Jul 2025 17:09:54 +0800</pubDate>
        
        <guid>https://skylm808.github.io/p/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%88%90%E5%8A%9F/</guid>
        <description>&lt;h2 id=&#34;-建博客成功&#34;&gt;🎉 建博客成功！
&lt;/h2&gt;&lt;p&gt;欢迎来到我的技术博客！这是我的第一篇文章，标志着我正式开始了技术写作之旅。&lt;/p&gt;
&lt;h3 id=&#34;关于这个博客&#34;&gt;关于这个博客
&lt;/h3&gt;&lt;p&gt;这个博客主要用来分享我在编程学习和工作中的心得体会，主要会涉及以下技术领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编程语言&lt;/strong&gt;: Java, Go, C++, Python&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算法与数据结构&lt;/strong&gt;: 算法题解、数据结构分析&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术总结&lt;/strong&gt;: 项目经验、技术难点解决方案&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学习笔记&lt;/strong&gt;: 新技术学习记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;未来计划&#34;&gt;未来计划
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;持续更新技术文章&lt;/li&gt;
&lt;li&gt;分享实际项目经验&lt;/li&gt;
&lt;li&gt;记录学习过程中的思考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;期待与大家一起交流学习！ 🚀&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
